#!/usr/bin/env python
#-*- coding: utf-8 -*-
import webbrowser
import time
import datetime

from flask import Flask, render_template, request, json, make_response, request
from flask_triangle import Triangle
import redis
import yara

import decoder
import crackers
import heuristics
import config
import utils

app = Flask(__name__)
# Create a Triangle Flask app, this provides a jinja2 angular filter for angular expressions
angular = Triangle(app)
r = redis.StrictRedis.from_url(config.redis_server)


@app.route("/")
def index():
    """
    Homepage for the application
    """
    if "remove" in request.args:  # User want to delete the selected analysis
        key = request.args["remove"]
        task = crackers.app.AsyncResult(key)
        if not task.ready():  # Terminate the task if it is still running
            task.revoke(terminate=True)
        r.delete("session-"+key)
    keys = r.keys("session-*")
    sessions = []
    for key in keys:
        data = json.loads(r.get(key))
        task = crackers.app.AsyncResult(data["sessionId"])
        # Load status of the task to display it in a table
        if task.status == "REVOKED":
            data["status"] = "revoked"
        elif task.status == "SUCCESS":
            data["status"] = "finished"
        elif task.failed():
            data["status"] = "failed"
        else:
            data["status"] = "pending"
        sessions.append(data)
    # Sort analyses having the most recent on top
    sessions = sorted(sessions, key=lambda x: x["time"])[::-1]
    return render_template("index.tpl", sessions=sessions, datetime=datetime)

@app.route("/sandbox")
@app.route("/sandbox/<taskId>")
def sandbox(taskId=None):
    """
    Sandbox page to create a new analysis or display an already existing one
    """
    return render_template("sandbox.tpl", taskId=taskId)

@app.route("/administration")
def administration():
    """
    Administration page
    """
    if "flushall" in request.args:  # User want to delete all the dat from the database
        r.flushdb()
    elif "terminateall" in request.args:  # User want to terminate all the running tasks
        crackers.app.control.purge()
        for worker in crackers.app.control.inspect().active().values():
            for active_task in worker:
                # Terminate the running task immediately
                crackers.app.control.revoke(active_task["id"], terminate=True, signal='SIGKILL')
    # Get a list of cluster nodes by sending them a ping
    workers = crackers.app.control.ping(timeout=0.5)
    return render_template("administration.tpl", workers=workers)

@app.route("/details/<md5>")
def details(md5):
    """
    Display a details of result by MD5 checksum of the result data
    """
    data = json.loads(r.get("decoded-"+md5))
    return render_template("details.tpl", datetime=datetime, **data)

@app.route("/download/<md5>")
def download(md5):
    """
    Download a file by it's MD5 checksum
    """
    data = utils.get_file(md5)
    response = make_response(data)
    # Force download to the browser because sometimes it may try to display it as a webpage
    response.headers["Content-Disposition"] = "attachment; filename={}.bin".format(md5)
    return response

@app.route("/crack", methods=["POST"])
def crack():
    """
    Crack API endpoint to spawn a celery task based on submitted JSON configuration
    """
    params = request.get_json()  # Parameters sent from angular
    # Select a set of rules
    if params["rule_set"] == "default":
        score = ()
    elif params["rule_set"] == "custom":
        score = ("custom", params["rules"])
    if params["dataType"] == "text":  # we received a text as a data
        if params["encoding"] == "base64":  # It's base64 encoded, we need to decode it
            decoded = decoder.decode_base64(params["data"])
        else:  # it's in plaintext/bytes that is not encoded as base64
            decoded = params["data"]
    elif params["dataType"] == "file":  # we received an uploaded file as a data
        decoded = decoder.decode_base64(params["data"])
    else:  # user selected to load data from a previously created session, so we load it
        session = json.loads(r.get("session-" + params["session"]))  # load session data
        params["file"] = session["file"]  # Get a MD5 reference to the file
        decoded = utils.get_file(session["file"])  # load our file from database
    if params.get("analysis") == "brute_force":  # user selected the brute force analysis
        result = str(crackers.brute_force.delay(decoded, params["functions"], score))  # spawn a celery task for cracking
    else:  # User want to perform the automated analysis
        result = str(crackers.automated_analysis.delay(decoded, score))
    # We will store a file in redis and create a refence to it so we can load it later
    if "data" in params:  # Store the data submitted by user if he don't selected the previous analysis option
        params["file"] = utils.store_file(decoded)
        del params["data"]  # delete data because we already stored it in db, we have a reference for it in "file" key
    params["sessionId"] = result
    params["time"] = time.time()
    r.set("session-" + result, json.dumps(params))  # save session into db
    r.expire("session-" + result, config.expiration)
    return json.dumps({"taskId": result})

@app.route("/crack/<taskId>")
def crack_result(taskId):
    """
    Return JSON informations of the running/finished celery task
    """
    task = crackers.app.AsyncResult(taskId)
    result = {
        "ready": task.ready(),  # Has task already finished?
        # "result": task.result if not task.failed() and not task.status == "REVOKED" else None,
        "result": map(json.loads, r.lrange("result-"+taskId, 0, -1)),  # Results found during the analysis
        "status": r.hgetall(taskId),
        "task_status": task.status,
        "failed": task.failed()  # Determine if an exception occured during the cracking due to the bug
    }
    return json.dumps(result)

@app.route("/loadsession/<taskId>")
def load_session(taskId):
    """
    Load a session configuration when the user open an already created analysis
    """
    return r.get("session-"+taskId)

@app.route("/check_yara", methods=["POST"])
def check_yara():
    """
    Check user's custom yara rules for syntax errors
    """
    rule = request.get_json()
    ok = True
    try:
        yara.compile(source=rule["rule"])
    except yara.YaraSyntaxError:  # Yara rules can't be compiled, user screwed up...
        ok = False
    return json.dumps({"ok": ok})

if __name__ == "__main__":
    #webbrowser.open("http://localhost:5000")
    app.run(debug=True)
