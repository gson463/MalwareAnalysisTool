import base64
from functools import wraps


def chain_function(fun):
    @wraps(fun)
    def wrapper(data, chain=[], config=[], *args, **kwargs):
        """
        Create a chain of functions from the wrapped function
        """
        # Enumerate each result and sequence of operations of the returned result
        for result, key in fun(data, *args, **kwargs):
            if not chain:  # There are no more functions in the chain, yield the result as is
                yield result, key
            else:
                if config:
                    cfg = config[0]
                else:
                    cfg = {}  # There is no configuration for the next function in a chain, create an empty one
                #Enumerate each result and sequence of operations and pass it to the next function in the chain
                for sub_result, sub_key in chain[0](result, chain=chain[1:], config=config[1:], **cfg):
                    yield sub_result, key + sub_key
    return wrapper


def decode_base64(data):
    """
    Return Base64 decoded data with stripped whitespace
    """
    return data.strip().decode("base64")

def transform_key(key, init_key, boundary=255):
    """
    Shift the key for the operation with rotation from the init_key if it exceed the max key value
    """
    key = (key + init_key)
    if key < 0:
        key += boundary
    return key%(boundary + 1)

@chain_function
def byte_xor(data, start=1, stop=255, key_change=0):
    """
    XOR operation function for data transformation
    """
    data = map(ord, data)
    for key in range(start, stop+1):
        decoded = map(lambda (ix, x): x^transform_key(key, ix*key_change), enumerate(data))
        yield str(bytearray(decoded)), [("xor", key, key_change)]

@chain_function
def byte_and(data, start=1, stop=255, key_change=0):
    """
    AND operation function for data transformation
    """
    data = map(ord, data)
    for key in range(start, stop+1):
        if key == 0:
            continue
        decoded = map(lambda (ix, x): (x&transform_key(key, key_change*ix)), enumerate(data))
        yield str(bytearray(decoded)), [("and", key, key_change)]

@chain_function
def byte_add(data, start=1, stop=255, key_change=0):
    """
    ADD operation function for data transformation
    """
    data = map(ord, data)
    for key in range(start, stop+1):
        if key == 0 or key == 255:
            continue
        decoded = map(lambda (ix, x): transform_key(x + key, key_change*ix), enumerate(data))
        yield str(bytearray(decoded)), [("add", key, key_change)]

@chain_function
def byte_rol(data, start=1, stop=8, key_change=0):
    """
    ROL (Rotation of bits) operation for data transformation
    """
    data = map(ord, data)
    for key in range(start, stop+1):
        if key == 0:
            continue
        decoded = map(lambda (ix, x): (x << transform_key(key, key_change*ix, 8) | x >> (8-transform_key(key, key_change*ix, 8))) & 0xFF, enumerate(data))
        yield str(bytearray(decoded)), [("rol", key, key_change)]

@chain_function
def byte_sub(data, start=1, stop=255, key_change=0):
    """
    SUB operation function for data transformation
    """
    data = map(ord, data)
    for key in range(start, stop+1):
        if key == 0 or key == 255:
            continue
        decoded = map(lambda (ix, x): transform_key(x - key, key_change*ix), enumerate(data))
        yield str(bytearray(decoded)), [("sub", key, key_change)]


# Array to map function to names, used for mapping from the API
decoders = {
    "xor": byte_xor,
    "and": byte_and,
    "add": byte_add,
    "rol": byte_rol,
    "sub": byte_sub
}


def test_functions(data="string"):
    for function in decoders.values():
        for key_change in range(-5, 5):
            list(function(data, key_change=key_change))

